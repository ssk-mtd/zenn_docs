---
title: "test"
emoji: "ğŸ¡"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [Go, Discord]
published: True
---
# èƒŒæ™¯
ã“ã“æœ€è¿‘ discord ã‚’ã‚ˆãç”¨ã„ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼ˆä»²é–“å†…ã ã¨ LINE ã‚ˆã‚Š discord ã®ã»ã†ãŒä½•ã‹ã¨ä¾¿åˆ©ï¼‰ï¼ãã‚“ãªä¾¿åˆ©ãª discord ã§ã™ãŒï¼Œã©ã‚“ãªä»•çµ„ã¿ã§å‹•ã„ã¦ã„ã‚‹ã®ã‹ï¼Œã©ã“ã¾ã§éŠã¹ãã†ã‹ãŒæ°—ã«ãªã£ãŸã®ã§ï¼Œ discord Bot ã¨ã—ã¦å®Ÿè£…ã—ãªãŒã‚‰éŠã‚“ã§ã¿ã¾ã—ãŸï¼ã“ã®è¨˜äº‹ã¯ï¼Œãã®éš›ã®ãƒ¡ãƒ¢ã§ã™ï¼

# å®Ÿéš›ã‚„ã£ãŸã“ã¨
[ä»¥å‰](https://zenn.dev/dozenkomeda/articles/4375f37d9dfca5)ã®å®Ÿè£…ã‚’åŸºã«ã—ã¦ï¼Œä¸»ã«ãƒœã‚¤ã‚¹ãƒãƒ£ãƒƒãƒˆã®ä»•çµ„ã¿ã‚’ golang ã§å®Ÿè£…ã—ãªãŒã‚‰é›°å›²æ°—ã‚’ç¢ºã‹ã‚ã‚‹ç¨‹åº¦ã®ã“ã¨ã§ã™ï¼æœ¬å½“ã§ã‚ã‚Œã°stftã§éŸ³å£°ã®å¯è¦–åŒ–ãã‚‰ã„ã¾ã§ã—ãŸã‹ã£ãŸã®ã§ã™ãŒï¼Œ golang ã® channel å‹ã¨éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯å‘¨ã‚Šã§æ‰‹ã“ãšã‚Šï¼Œæ™‚é–“ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ...

# webRTC
Discord ã§ã¯ webRTC (Real Time Communication) ã‚’ç”¨ã„ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªéŸ³å£°ãƒ»æ˜ åƒãªã©ã®ç›¸äº’é€šä¿¡ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ï¼ã“ã‚Œã¯ï¼Œãã®åã®é€šã‚Š web (HTML5) ã®ä»•æ§˜ã®ä¸€ã¤ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡æŠ€è¡“ã§ã™ï¼

https://www.iwass.co.jp/column/column-07.html
https://www.paltek.co.jp/techblog/techinfo/230201_01

ç‰¹ã«éŸ³å£° (Audio) ã«ã¤ã„ã¦ã¯ï¼Œä¸€èˆ¬çš„ã« [Opus](https://ja.wikipedia.org/wiki/Opus_(%E9%9F%B3%E5%A3%B0%E5%9C%A7%E7%B8%AE)) ã¨ã„ã†å½¢å¼ã«åœ§ç¸®ã•ã‚Œã¦é€å—ä¿¡ã•ã‚Œã¾ã™ï¼

# Discord ãƒœã‚¤ã‚¹ãƒãƒ£ãƒƒãƒˆã®ä»•çµ„ã¿
discord ã®ãƒœã‚¤ã‚¹ãƒãƒ£ãƒƒãƒˆã®æƒ…å ±ã¯ï¼Œ`VoiceConnection` ã¨ã„ã†æ§‹é€ ä½“ã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ï¼ä¸­èº«ã¯ä»¥ä¸‹ï¼
>type VoiceConnection struct {
>	sync.RWMutex
>
>	Debug     bool // If true, print extra logging -- DEPRECATED
>	LogLevel  int
>	Ready     bool // If true, voice is ready to send/receive audio
>	UserID    string
>	GuildID   string
>	ChannelID string
>
>	OpusSend chan []byte  // Chan for sending opus audio
>	OpusRecv chan *Packet // Chan for receiving opus audio
>	// contains filtered or unexported fields
>}

https://pkg.go.dev/github.com/bwmarrin/discordgo#section-readme

ã“ã‚Œã‚’å®Ÿéš›ã«ç”Ÿæˆã™ã‚‹é–¢æ•°ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ï¼
```go
func onMessageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {
    c, err := s.State.Channel(m.ChannelID)
    if err != nil {
        log.Println("Error channel state: ", err)
    }
    vcsession, _ = s.ChannelVoiceJoin(c.GuildID, "channel id", false, false)
    // vcsession : type VoiceConnection struct
}
```

ã¾ãŸï¼Œã“ã®æ§‹é€ ä½“ã®ä¸­ã«ã‚ã‚‹ `OpusSend`ï¼Œ `OpusRecv` ã¨ã„ã†ã®ãŒï¼ŒwebRTC ã«ã‚ˆã£ã¦é€å—ä¿¡ã•ã‚Œã‚‹Opusã®å¤‰æ•°ã§ã‚ã‚‹ï¼
ã¡ãªã¿ã«ï¼Œ`chan` ã¨ã‚ã‚‹ã®ã¯ï¼Œãƒã‚¤ãƒ³ã‚¿å¤‰æ•°ã‚’è¡¨ã—ã¦ã„ã‚‹ï¼

å®Ÿéš›ã« bot ãŒéŸ³å£°ã‚’é€å—ä¿¡ã™ã‚‹å ´åˆã«ã¯ï¼Œä½•ã‹ã—ã‚‰ã®å¤‰æ›ï¼ˆãƒã‚¤ã‚ºé™¤å»ãªã©ï¼‰ã‚’è¡Œã†ã“ã¨ã«ãªã‚‹ï¼ã—ã‹ã—ï¼ŒOpus ã¯åœ§ç¸®å½¢å¼ã§ã‚ã‚‹ãŸã‚ï¼Œãã®ã¾ã¾ã§ã¯æ“ä½œãŒã§ããªã„ï¼
ãã®ãŸã‚ï¼ŒOpus ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—PCMå½¢å¼ã¨ã™ã‚‹ã“ã¨ã§ä»»æ„ã®æ“ä½œã‚’å¯èƒ½ã«ã—ï¼Œãã‚Œã‚’ã¾ãŸOpusã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãªãŠã™ï¼
ã“ã®ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã«é–¢ã™ã‚‹æ“ä½œã«ã¯ä»¥ä¸‹ã‚’ç”¨ã„ãŸï¼
https://github.com/hraban/opus

# å®Ÿé¨“ã¨çµæœ
å®Ÿé¨“ã¨ã—ã¦ï¼Œãƒ¦ãƒ¼ã‚¶ã‹ã‚‰ãƒœã‚¤ã‚¹ãƒãƒ£ãƒƒãƒˆã«å…¥åŠ›ã•ã‚ŒãŸéŸ³å£°ã‚’æ¤œå‡ºã—ï¼Œãƒ‡ã‚³ãƒ¼ãƒ‰åŠã³ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã®ã¡ã«ãã®ã¾ã¾é€ã‚Šè¿”ã™echoæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ãŸï¼
ä½¿ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ã¯ä»˜éŒ²ã¨ã—ã¦è¨˜äº‹ã®æœ€å¾Œã«å¼µã‚Šä»˜ã‘ã¦ã„ã‚‹ï¼
çµæœã¨ã—ã¦ã¯ï¼Œã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã®å¤‰æ›ã‚’ã—ãªã„å ´åˆã«ã¯ã‚¯ãƒªã‚¢ã«èã“ãˆãŸãŒï¼Œã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã—ãŸå ´åˆã«ã¯é«˜é€Ÿã«å†ç”Ÿã•ã‚Œã¦ãŠã‚Šï¼Œã©ã“ã‹ãŒèª¤ã£ã¦ã„ã‚‹ã®ã ãŒåŸå› ã¯ã„ã¾ã ä¸æ˜ã§ã‚ã‚‹ï¼ï¼ˆèª°ã‹åŠ©ã‘ã¦ã‚¯ãƒ¬ãƒ¡ãƒ³ã‚¹ï¼‰

# ã¾ã¨ã‚
Discord ã®éŸ³å£°é€šä¿¡ã«ã¤ã„ã¦ãƒ¡ãƒ¢ã—ã¾ã—ãŸï¼ä»Šå¾Œã¯ï¼ŒéŸ³å£°ã®ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¨å¯è¦–åŒ–ã‚’é€²ã‚ï¼ŒéŸ³å£°ç¬¦å·åŒ–ã‚ãŸã‚Šã«ã¤ã„ã¦å‹‰å¼·ã—ãŸã„ã¨æ€ã£ã¦ã„ã¾ã™ï¼
å¯è¦–åŒ–ã«ã¤ã„ã¦ã¯ï¼Œdiscord Bot ãŒæ˜ åƒé…ä¿¡å¯èƒ½ã«ãªã£ã¦ãã‚Œã‚Œã°ãªã...

# å‚è€ƒ

https://zenn.dev/fog/scraps/327d8b40148d1f

https://www.aatomu.work/blog/2025010801_discord_opus

https://zenn.dev/yukihaga/scraps/48e39f1e5ec3bf

https://r9y9.github.io/blog/2014/06/08/gossp-speech-signal-processing-for-go/

https://qiita.com/KEINOS/items/731ce80dd7a5485caccc

https://www.infraexpert.com/study/telephony2.html

# ä»˜éŒ²ï¼šä»Šå›ã®å®Ÿè£…
```go
package main
import (
   "flag"
   "fmt"
   "log"
   "os"
   "strings"
   "os/signal"
   "syscall"

   "github.com/bwmarrin/discordgo"
	"gopkg.in/hraban/opus.v2"
   
)

var (
   split_q []string
   vcsession   *discordgo.VoiceConnection
   HelloWorld  = "!hello"
   chanList    = "!clist"
   vcJoin      = "!vcjoin"
   vcLeave     = "!vcleave"
)

func main() {
   Token := os.Getenv("TOKEN")
   discord, err := discordgo.New("Bot " + Token)
   if err != nil {
   	fmt.Println("ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—", err)
   }

   // Add Event Handler
   discord.AddHandler(onMessageCreate)
   // vcsession.AddHandler(onVoiceReceived) //éŸ³å£°å—ä¿¡æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© <- TODO

   
   err = discord.Open()
   if err != nil {
   	fmt.Println("ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚ªãƒ¼ãƒ—ãƒ³ã«å¤±æ•—", err)
   }

   defer discord.Close()

   fmt.Println("Listening...")
   waitForExitSignal()
}

func waitForExitSignal() {
   stopBot := make(chan os.Signal, 1)
   signal.Notify(stopBot, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)
   <-stopBot
}

func onMessageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {
   clientID := os.Getenv("CLIENT_ID")     // Bot's ID
   u := m.Author

   if u.ID != clientID {
      fmt.Printf("%20s %20s(%20s) > %s\n", m.ChannelID, u.Username, u.ID, m.Content)
      c, err := s.State.Channel(m.ChannelID)
      if err != nil {
         log.Println("Error channel state: ", err)
      }
      switch {
         case strings.HasPrefix(m.Content, fmt.Sprintf("<@%s> %s", clientID, HelloWorld)):
            sendMessage(s, m.ChannelID, "Hello "+u.Username, m.Reference())
         
         case strings.HasPrefix(m.Content, fmt.Sprintf("<@%s> %s", clientID, chanList)):
		      guildChannels, _ := s.GuildChannels(c.GuildID)
            var sendText string
            for _, a := range guildChannels{
               sendText += fmt.Sprintf("Type: %v, Name: %v(ID: %v)\n", a.Type, a.Name, a.ID)
            }
            sendMessage(s, m.ChannelID, sendText, m.Reference())

         case strings.HasPrefix(m.Content, fmt.Sprintf("<@%s> %s", clientID, vcJoin)):
            split_q = strings.Split(m.Content, " ")
            log.Printf("%s\n", split_q)
            vcsession, _ = s.ChannelVoiceJoin(c.GuildID, split_q[2], false, false)
            voiceControl(vcsession)

         case strings.HasPrefix(m.Content, fmt.Sprintf("<@%s> %s", clientID, vcLeave)):
            vcsession.Disconnect()
      }
   }

}

func sendMessage(s *discordgo.Session, channelID string, msg string, reference *discordgo.MessageReference) {
   _, err := s.ChannelMessageSendReply(channelID, msg, reference)
   if err != nil {
   	log.Println("Error sending message: ", err)
   }
}

func voiceControl(v *discordgo.VoiceConnection) {
   recv := make(chan *discordgo.Packet)
   go rPCM(v, recv)

   send := make(chan []int16, 2)
   go sPCM(v, send)

   i := 0
	for p := range recv{
      log.Print(n, i)
      i++

	  send <- p.PCM
      
	}
}

func rPCM(v *discordgo.VoiceConnection, c chan *discordgo.Packet) {
   pcm := make([]int16, int(48000*2*20/1000))     // sample_rate = 48000, channels = 2, 20ms
   mode := "recieve"
   for{
      p := <- v.OpusRecv
      dec, _ := opus.NewDecoder(48000, 2)
      n, err := dec.Decode(p.Opus, pcm)
      if err != nil {
         log.Print(err)
         return
      }
      p.PCM = pcm[:n*2]
      c <- p

      pcm_float := make([]float64, n)
      for i := 0; i < n; i++ {
         pcm_float[i] = float64(pcm[i])
      }

      if mode=="echo" {
         v.OpusSend <- p.Opus
      }
   }
}

func sPCM(v *discordgo.VoiceConnection, pcm chan []int16) {
   for {
      p := <- v.OpusRecv
      p.PCM = <- pcm
      enc, _ := opus.NewEncoder(48000, 2, opus.AppVoIP)
      // enc, _ := opus.NewEncoder(48000, 2, opus.AppAudio)
      n, err2 := enc.Encode(p.PCM, p.Opus)
      if err2 != nil {
         log.Print("err2")
         log.Print(err2)
         return
      }
      p.Opus = p.Opus[:n]
      v.OpusSend <- p.Opus
   }
}
```